---
title: "Visualization of nonlinear interactions"
author: "Jacolien van Rij"
date: "version `r format.Date(Sys.Date(), '%B %d, %Y')`"
bibliography: bibliography.bib
output:   
  rmarkdown::html_document:
    fig_caption: yes
    toc: false
    theme: readable
    highlight: default
vignette: >
  %\VignetteIndexEntry{Visualization of nonlinear interactions in itsadug}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
<style>
td      {padding:5pt;}
h1, h2, h3, h4 {padding: 1em 0em.5em 0em;}
.tocblock    {
  background:#cccccc;
  border: 1pt solid white;
  padding: .5em;
  margin: 1em 0em;
}
.mark {
  backgroundcolor:yellow;
}
</style>
```{r, include=FALSE, echo=FALSE}
library(itsadug)
infoMessages('off')
```

The package **`itsadug`** includes several plot functions to visualize the estimates of Generalized Additive (Mixed) Models (GAMM) implemented using the package **`mgcv`**  [@Wood_2006; -@Wood_2011].


This paper presents a short overview of:

- the available plot functions in the packages `mgcv` (version `r packageVersion('mgcv')`) and `itsadug` (version `r packageVersion('itsadug')`);
- the functions to retrieve predicted values from a GAMM, and how these could be used to create custom plots;
- the plot functions for inspection of the residuals. 

Two GAMM models were fitted on the data set `simdat` for illustrating the various plot functions. This data set simulates psychophysiological time series data. See `help(simdat)` for more info. More information about the models can be found in `help(models)`. 


```{r, include=FALSE, results='hide'}
library(itsadug)
data(simdat)

# For illustration purposes, we build a GAMM model
# with a nonlinear interaction, two groups, and
# random wiggly smooths for Subjects:
m1 <- bam(Y ~ Group + s(Condition, k=5)
  + te(Time, Trial, by=Group)
  + s(Time, Subject, bs='fs', m=1, k=5),
  data=simdat, method='fREML')

# Also for illustration purposes, a second model was fitted 
# that included an AR1 model. 

# Rho was arbitrarily set to .5:
rho <- 0.5
# The start of each time series (unique Subject-Trial 
# combination) is marked as TRUE:
simdat <- start_event(simdat, column="Time", 
    event=c("Subject", "Trial"), label.event="start.event")
# Fit the model:
m2 <- bam(Y ~ Group + s(Condition, k=5)
  + te(Time, Trial, by=Group)
  + s(Time, Subject, bs='fs', m=1, k=5),
  data=simdat, rho=rho, AR.start=simdat$start.event,
  method='fREML')
```

The function **`gamtabs`** converts the summary quickly in a Latex table or in a HTML table (specify `type="html"`), which could be included in a `knitr` file. 

<a id="summary_m1"></a>
```{r, eval=TRUE, results='asis'}
gamtabs(m1, caption="Summaty of m1", 
    comment=FALSE, type='html')
```

GAMM models may include different types of model terms: *parametric terms* (i.e., intercept, linear slopes, and a constant adjustments of slope or intercept) and *smooth terms* (smooth functions applied to one or more predictors). This distinction is visible in the [summary of model `m1`](#summary_m1). 

# <a id="toc"></a>Table of contents
<div class="tocblock">
[PART A. Visualizing a GAMM model](#partA)

[*1. Plotting model terms (partial effects)*](#A1)

   - [mgcv's plot.gam](#A1.plot.gam)
   - [pvisgam](#A1.pvisgam)

[*2. Plotting summed effects with / without random effects*](#A2)

   - [plot_smooth](#A2.plot.smooth)
   - [fvisgam](#A2.fvisgam) 
   - [mcgv's vis.gam](#A2.vis.gam)
   - [plot_parametric](#A2.plot.parametric)
   
[*3. Plotting differences*](#A3)

   - [plot_diff2](#A3.plot.diff2)
   - [plot_diff](#A3.plot.diff)


[*4. Visualizing residuals*](#A4)
   
   - [check_resid](#A4.check.resid)
   - [check_normaldist](#A4.check.normaldist)
   - [acf_resid](#A4.acf.resid)
</div>

<div class="tocblock">
[PART B. Advanced plots](#partB)

[*1. Plotting random effects*](#B1)

   - [get_random](#B1.get.random)
   - [get_modelterm](#B1.get.modelterm)

*2. Combining model terms (partial effect)*

   - get_modelterm 
   - plotSurfaces

*3. More about predict functions predictions*

   - get_predictions 
   - get_difference
   - predict.gam
</div>

<div class="tocblock">
PART C. Plot utility functions

*1. Plotting smooths*
  
   - emptyPlot
   - plot_error  
   - find_difference
   - addInterval
   - fillArea
   - getCoords and getFigCoords
   
*2. Plotting surfaces*

   - color_contour
   - fadeRug
   - gradientLegend

*3. Other plot functions*

   - alpha and alphaPalette
</div>



# <a id="partA"></a>PART A. Visualizing a GAMM model

This section illustrates the key functions for plotting GAMM models. 

**Terminology.** A *partial* effect is the estimated effect of a single model term on the dependent variable. The *summed effects* is the model's estimate for the dependent variable in a given situation. It basically is the sum of all model terms. 

## <a id="A1"></a>*1. Plotting model terms*

Here we illustrated how to plot the *partial* effects, i.e., the isolated effects of the model terms. 

### <a id="A1.plot.gam"></a>mgcvâ€™s plot.gam

The function `plot.gam` of `mgcv` is used for plotting different types of model terms. See `help(plot.gam)` for more information on the different arguments.


#### Plotting a 1-dimensional smooth

By default, 1-dimensional plots have the same y-scale. To restrict the range of the y-axis to the effect of the model term include `scale=0`. The argument `shade` determines whether the confidence interval is indicated with a shaded region or with two lines indication the boundaries. The argument `rug` allows or prevents plotting the data points as 'rug', shown as ticks on the x-axis.

```{r A1.plotgam.smooth, fig.width=8, fig.height=4,fig.cap="Figure: Partial effect of <it>Condition</it>."}
# devide the window in two plot panels:
par(mfrow=c(1,2), cex=1.1)
# plot default style:
plot(m1, scale=0, select=1)
# add title:
title(main="Default")

# change some plot settings:
plot(m1, select=1, scale=0, bty='n',
  shade=TRUE, rug=FALSE, shift=coef(m1)[1])
# add horizontal line:
abline(h=0)
# add vertical line:
abline(v=0, lty=3)
# add title:
title(main="Shifted: intercept included")
```


#### Plotting a surface

By default, surfaces are plotted as contour plots with error bars. As these plots may be difficult to read, color coding can be added by using the argument `scheme=2`. Currently, only the color palette `heat.colors`, but no other color palettes, could be used.

```{r A1.plotgam.surface, fig.width=8, fig.height=4,fig.cap="Figure: Partial effect of the interaction <it>Time x Trial</it> for the children."}
# devide the window in two plot panels:
par(mfrow=c(1,2), cex=1.1)
# plot default style:
plot(m1, select=2, rug=FALSE)
# add title:
title(main="Default")

# add colored background:
plot(m1, select=2, rug=FALSE, scheme=2, 
  main="TimexTrial, children",
  cex.axis=1.5, cex.lab=1.5)
```

Alternative(s): [pvisgam](#A1.pvisgam).


#### Plotting random effects

```{r A1.plotgam.random, fig.width=4, fig.height=4,fig.cap="Figure: Random effects"}
# plot default style:
plot(m1, select=4)
# add title:
title(main="Random effects")
# add horizontal line:
abline(h=0)
```


#### Plotting parametric terms

```{r A1.plotgam.parametric, fig.width=4, fig.height=4,fig.cap="Figure: Parametric coefficients."}
# plot default style:
plot(m1, all.terms=TRUE, select=5, rug=FALSE)
# add title:
title(main="Parametric coefficients")
```


#### Limitations

- Currently, a 1-dimensional smooths can not be added to an existing plot;

- Model terms with more than two continuous cannot be plotted (use [pvisgam](#A1.pvisgam) instead);

- Limited layout options.

Alternative(s): <span class="mark">get_modelterm</span>, <span class="mark">get_random</span>.

[[Table of contents]](#toc)

### <a id="A1.pvisgam"></a>pvisgam

The function `pvisgam` plots partial interaction surfaces. It requires as input the model, the number of the model term (argument `select`), and the predictors to plot on the x- and y-axis respectively (argument `view`). The function can plot also more comple interactions.

```{r A1.pvisgam, fig.width=8, fig.height=4,fig.cap="Figure: Partial effect of the interaction <it>Time x Trial</it> for the children."}
# devide the window in two plot panels:
par(mfrow=c(1,2), cex=1.1)
# plot children:
pvisgam(m1, select=2, view=c("Time", "Trial"),
    zlim=c(-15,10),
    main='Children')

# change layout, zlimit, axes, ...
pvisgam(m1, select=3, view=c("Trial", "Time"),
    zlim=c(-15,15), color='terrain', labcex=1.5,
    main='Adults: different axes!',
    add.color.legend=FALSE)
```

**Warnings:**

- The surfaces might look different when being plot with different z-range (`zlim`), which changes the colors and contour lines being plot. 

- Highly similar in appearance to the function [fvisgam](#A2.fvisgam). Therefore, it is good practice to report which function and settings were used to generate the plot.

Alternative(s): [plot.gam](#A1.plot.gam), <span class="mark">get_modelterm</span>

[[Table of contents]](#toc)

## <a id="A2"></a>*2. Plotting summed effects with / without random effects*

Here we illustrated how to plot the *summed* effects, i.e., the model's estimate for the dependent variable in a certain condition.

### <a id="A2.plot.smooth"></a>plot_smooth

The function `plot_smooth` plots the 1-dimensional estimated smooth for a certain predictor specified in `view`. Generally, the predictor is included in the model as 1-dimensional smooth, for example *Condition* in model `m1`. The argument `cond` is used for specifying the values of the other predictors. Compare the plots with the *partial* effects plots for *Condition* (see [plot.gam](#A1.plot.gam)).

```{r,plotSmooth1, fig.width=8, fig.height=4, fig.cap="Figure: Using plot_smooth for plotting a one dimensional smooth from model <code>m1</code> including random effects (Left) or excluding random effects (Right)."}
par(mfrow=c(1,2), cex=1.1)

# plot the smooth for Condition
plot_smooth(m1, view="Condition",  cond=list(Group='Children'), 
  rug=FALSE, ylim=c(-8,12), main='Condition')
# plot the smooth for Condition without random effects
plot_smooth(m1, view="Condition", 
  rug=FALSE, ylim=c(-8,12), main='Condition, excl. random', 
  rm.ranef=TRUE)
# ... and add a smooth for adults:
plot_smooth(m1, view="Condition",  cond=list(Group='Adults'), 
  add=TRUE, col='red', rm.ranef=TRUE, rug=FALSE)
# add legend:
legend('bottomleft',
  legend=c('Children', 'Adults'),
  col=c(1,'red'), lwd=1, cex=.75,
  bty='n')
```

Generally, `plot_smooth` is used for visualizing a 1-dimensional smooth. However, `plot_smooth` could also be used to visualize a slice from an interaction surface. The argument `cond` is used to specify values for other predictors, and the argument `plot_all` specifies a predictor for which all levels need to be plotted in a single plot.

(See for more information on the function [fvisgam](#A2.fvisgam) below. )

```{r,plotSmooth2, fig.width=12, fig.height=4, fig.cap="Figure: Using plot_smooth for extracting a one dimensional smooth from an interaction surface in model <code>m1</code>."}
par(mfrow=c(1,3), cex=1.1)

# plot the interaction surface for Time and Trial for 
# adults using fvisgam:
fvisgam(m1, view=c("Time", "Trial"), 
    cond=list(Group="Adults"),
    zlim=c(-10,20), rm.ranef=TRUE,
    main='Adults')
# add dashed line to indicate slice:
abline(v=750, lty=2, lwd=2)

# plot the smooths for all levels of group:
plot_smooth(m1, view="Trial", cond=list(Time=750),
    plot_all="Group", rm.ranef=TRUE, 
    legend_plot_all='bottomright',
    rug=FALSE, ylim=c(-10,20))
# add text
mtext('(Time=750ms)', side=3, line=0)

# plot the interaction surface for Time and Trial for 
# children using fvisgam:
fvisgam(m1, view=c("Time", "Trial"), 
    cond=list(Group="Children"),
    zlim=c(-10,20), rm.ranef=TRUE,
    main='Children')
# add dashed line to indicate slice:
abline(v=750, lty=2, lwd=2)
```

Alternative(s): <span class="mark">get_predictions</span>

[[Table of contents]](#toc)

### <a id="A2.fvisgam"></a>fvisgam

The function `fvisgam` plots summed interaction surfaces. It requires as input the model, and the predictors to plot on the x- and y-axis respectively (argument `view`). The function could also plot more comple interactions.

The function is derived from `mgcv`'s [vis.gam](#A2.vis.gam) function. 

```{r, fvisgam,fig.width=8, fig.height=4, fig.cap="Figure: Summed effects surfaces for interaction <it>Time x Trial</it> for the children. Left: including random effect, Right: excluding random effects."}
par(mfrow=c(1,2))
# Note: specify zlim when comparing two plots
fvisgam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children'),
        main='Group=Children, incl.',
        zlim=c(-12,15))
fvisgam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children'),
        main='Group=Children, excl.',
        zlim=c(-12,15), rm.ranef=TRUE)
```

Some of the other options that are available:

- `cond` for specifiying specific conditions. For example, `cond=list(Group="Adults", Subject="a01")`.
- `color` for different color palettes (e.g., `color="terrain"`, or `color="bw"`). 
- `add.color.legend` for removing the color legend.
- `transform` accept a function for transforming the predictions. For example, use `transform=plogis` for transforming logits back (in logistic models). 
- `plot.type="persp"` will produce a `persp` plot.

Two other examples:

```{r, fvisgam2,fig.width=8, fig.height=4, fig.cap="Figure: Summed effects surfaces for interaction <it>Time x Trial</it> for the children. Illustrating different parameters."}
par(mfrow=c(1,2))

# exclude color legend and add rug:
fvisgam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children'),
        main='Untransformed values',
        color='terrain', nCol=50,
        zlim=c(-12,15), rm.ranef=TRUE,
        add.color.legend=FALSE)
# add rug:
fadeRug(simdat$Time, simdat$Trial)
# add manually color legend:
gradientLegend(c(-12,15), col=terrain.colors(50), pos=.875)

# transform estimates to inverse values:
inv <- function(x){ -1*x}
fvisgam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children'),
        main='Transformed values',
        zlim=c(-15,12), rm.ranef=TRUE,
        transform=inv)
```


**Warnings:**

- The surfaces might look different when being plot with different z-range (`zlim`), which changes the colors and contour lines being plot. 

- Highly similar in appearance to the function [pvisgam](#A1.pvisgam). Therefore, it is good practice to report which function and settings were used to generate the plot.

Alternative(s): [vis.gam](#A2.vis.gam), <span class="mark">get_predictions</span>

[[Table of contents]](#toc)

### <a id="A2.vis.gam"></a>vis.gam

Plots the same as [fvisgam](#A2.fvisgam), without legend and without the possibility to exclude random effects.

```{r, visgam, fig.width=8, fig.height=4, fig.cap="Figure: interaction <it>Time x Trial</it> for the children, Subject 'a01'. Left: contour plot. Right: perspective plot."}
par(mfrow=c(1,2))
# Note: specify zlim when comparing two plots
vis.gam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children', Subject='a01'),
        plot.type='contour', color='topo', main='Group=Children',
        zlim=c(-8,10))
vis.gam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children', Subject='a01'),
        plot.type='persp', color='topo', main='Group=Children',
        zlim=c(-8,10))
```


**Warnings:**

- The surfaces might look different when being plot with different z-range (`zlim`), which changes the colors and contour lines being plot. 

- Highly similar in appearance to the function [pvisgam](#A1.pvisgam). Therefore, it is good practice to report which function and settings were used to generate the plot.

Alternative(s): [fvisgam](#A2.fvisgam), <span class="mark">get_predictions</span>

[[Table of contents]](#toc)

### <a id="A2.plot.parametric"></a>plot_parametric

Here we illustrated how to plot the parametric effects, i.e., the model's average estimate for grouping predictors. Note that these estimates are not the coefficients, but *summed* effects.

- The argument `cond` could be used to specify the values of other, not visible predictors. In the plots below `Trial` is set to -5.

- The argument `rm.ranef` could be used to cancel out random effects from the estimates, as in the center plot below.

- The argument `parametricOnly` could be used to set all other predictors (including random effects) to 0. Note that with this setting, the estimates are still considered as *summed* effects, because the intercept is included. In addition, the error bars reflect the uncertainty of the other predictors when these have a value of zero. 

```{r, A2.plotparametric, fig.width=12, fig.height=4, fig.cap="Figure: Plotting parametric terms for Trial=-5."}
par(mfrow=c(1,3), cex=1.1)

plot_parametric(m1, pred=list(Group=levels(simdat$Group)), 
    cond=list(Trial=-5),
    main='default',
    xlab='estimate of Y')

 # see help(dotplot_error) for color options
plot_parametric(m1, pred=list(Group=levels(simdat$Group)), 
    cond=list(Trial=-5),
    color=c('black', 'red'),
    bg = c(alpha('black'), alpha('red')),
    main='rm.ranef',
    xlab='estimate of Y', rm.ranef=TRUE)

plot_parametric(m1, pred=list(Group=levels(simdat$Group)), 
    cond=list(Trial=-5),
    color=c('black', 'red'), 
    pch=c(4,15),
    main='parametricOnly',
    xlab='estimate of Y', parametricOnly=TRUE)
```


**Warning:**
The `parametricOnly` setting could provide misleading estimates, because a value of 0 is not always realistic. For example, a word with length 0 is never observed in the data, therefore the estimate could be strange.

Alternative(s): [plot.gam](#A1.plot.gam), <span class="mark">get_predictions</span>

[[Table of contents]](#toc)

## <a id="A3"></a>*3. Plotting differences*

Here we illustrated how to plot differences between conditions in smooths or surfaces.

### <a id="A3.plot.diff2"></a>plot_diff2

The differences in the surface *Time* by *Trial* between the adult participants and the children could be modeled using a binary predictor for age rather than a factor. A binary predictor would yield a difference surface. Alternatively, one could use the function **`plot_diff2`** to calculate and plot the difference surface based on the model's predictions. 

```{r,A3.plotdiff2, echo=TRUE, fig.width=8, fig.height=4,fig.cap="Figure: Difference surface for <code>Group</code> plotted with <code>plot_diff2</code>."}
par(mfrow=c(1,2))

# Default settings
plot_diff2(m1, view=c("Time","Trial"), 
        comp=list(Group=c("Adults", "Children")),
        zlim=c(-5,7.5),
        main="Difference, default")
# Change some parameters:
# - Condition=3 (does not make a difference here)
# - Remove random effects (does not make a difference here)
# - Plot confidence contours
plot_diff2(m1, view=c("Time","Trial"), 
        comp=list(Group=c("Adults", "Children")),
        cond=list(Condition=3),
        zlim=c(-5,7.5), rm.ranef=TRUE,
        plotCI=TRUE,
        main="Difference, excl. random")
```

The argument `cond` is used to set values for other predictors that are not visible in the plot. Note that these settings only change the differences when the predictors interact with the visualized predictors. 

The argument `rm.ranef` is used to exclude potential random effects. In the current model (model `m1`) the random effects are canceled out when the difference between the conditions is calculated. Therefore, excluding random effects does not change the differences. However, this is not always the case. 

Alternative(s): <span class="mark">get_difference</span>

[[Table of contents]](#toc)

### <a id="A3.plot.diff"></a>plot_diff

The function `plot_diff` plots a 1-dimensional smooth difference. 

```{r,A3.plotdiff, echo=TRUE, fig.width=8, fig.height=4,fig.cap="Figure: Difference surface for <code>Group</code> plotted with <code>plot_diff2</code>."}
par(mfrow=c(1,2))

# Default settings
plot_diff(m1, view="Time", 
        comp=list(Group=c("Adults", "Children")),
        shade=FALSE,
        ylim=c(-8,8),
        main="Difference Adults-Children")
# Add a plot for Trial=-10:
plot_diff(m1, view="Time", 
        comp=list(Group=c("Adults", "Children")),
        cond=list(Trial=-10), add=TRUE, col='red')
# Add a plot for Trial=10:
plot_diff(m1, view="Time", 
        comp=list(Group=c("Adults", "Children")),
        cond=list(Trial=10), add=TRUE, col='cyan')
# add legend:
legend('bottom',
    legend=c("default", 'Trial=-10', 'Trial=10'),
    lwd=2, col=c('black', 'red', 'cyan'),
    bty='n', cex=.85)

# incl. random effects:
plot_diff(m1, view="Time", 
        comp=list(Group=c("Adults", "Children")),
        cond=list(Trial=0),
        shade=FALSE,
        ylim=c(-8,8),
        main="Difference, Trial=0")
# excl.random effects:
plot_diff(m1, view="Time", 
        comp=list(Group=c("Adults", "Children")),
        cond=list(Trial=0), 
        col='green', 
        add=TRUE, rm.ranef=TRUE)
# add 99% confidence interval instead of 95%:
plot_diff(m1, view="Time", 
        comp=list(Group=c("Adults", "Children")),
        cond=list(Trial=0), col='green',
        f=2.58,  shade=FALSE,
        add=TRUE, rm.ranef=TRUE)
# add legend:
legend('bottom',
  legend=c('default', 'excl. random', 'excl. random, 99% CI'),
  lty=c(2,1,2), lwd=1,
  col=c('black', 'green', 'green'),
  fill=c(NA, alpha('green'), NA), border=NA,
  merge=TRUE,
  bty='n', cex=.85)
```

The value of `Trial` changes the shape of the difference, because the model includes an interaction between `Time`, `Trial` and `Group`. Therefore, a difference *surface* (see [`plot_diff2`](#A3.plot.diff2)) is more appropriate to visualize the difference between the age groups. The random effects, on the other hand, do not change the difference.

Alternative(s): <span class="mark">get_difference</span>

[[Table of contents]](#toc)


## <a id="A4"></a>*4. Visualizing residuals*

The vignette *acf* illustrates in detail the functions that are available for inspection of the residuals.
```{r, eval=FALSE}
vignette("acf")
```


### <a id="A4.check.resid"></a>check_resid

As model `m1` does not include and AR1 model, only the standard residuals are being plotted. The upper row shows the distribution of the residuals, whereas the bottom row shows the autocorrelation of the residuals.

Note that the `split_by` argument is optional and could be left out. It creates an ACF which is the average of the ACFs for each event defined by the split_by predictor(s). 

```{r check.resid, fig.width=8, fig.height=8}
check_resid(m1, split_by=c("Subject", "Trial"))
```

For a model *with* AR1 model included, the corrected residuals are plotted in red:
```{r check.resid2, fig.width=8, fig.height=8}
check_resid(m2, split_by=c("Subject", "Trial"))
```

Alternative(s): [qqnorm](#A4.check.normaldist), [check_normaldist](#A4.check.normaldist), [acf_resid](#A4.acf.resid)

[[Table of contents]](#toc)

### <a id="A4.check.normaldist"></a>check_normaldist

Generally, `qqnorm` is used to check the distribution of the residuals: this function plots the residuals against the theoretical quantiles of a normal distribution. If the residuals follow a normal distribution, the QQ plot shows a straight line. 

The function `check_normaldist` facilitates the interpretation of the QQ plot by plotting the (centered) density of the residuals (red line) together with the density of a normal distribution (gray area). 

```{r distribution, fig.width=8, fig.height=4}
par(mfrow=c(1,2), cex=1.1)

# Default QQ plot:
qqnorm(resid(m1))
qqline(resid(m1), col='red')

# density functions:
check_normaldist(resid(m1))
```

### <a id="A4.acf.resid"></a>acf_resid

To test for the autocorrelation, `acf_resid` could be used. The figure below shows the differences between the default ACF function, and `acf_resid`. Note that model `m2` includes an AR1 model, but model `m1` does not.

```{r acf.resid, fig.width=12, fig.height=8}
par(mfrow=c(2,3), cex=1.1)

# plots for model m1 (no AR1):

# 1. default ACF
acf(resid(m1), 
  main='default ACF m1',
  lag.max=20, ylim=c(-.2,1)) # for comparison
# 2. acf_resid
acf_resid(m1, 
  main='acf_resid m1', ylab='ACF', 
  max_lag=20, ylim=c(-.2,1))# for comparison
# 3. acf_resid
acf_resid(m1, split_pred=c("Subject", "Trial"),
  main='acf_resid m1,\n average',
  max_lag=20, ylim=c(-.2,1)) # for comparison

# plots for model m2 (incl. AR1):
# 4. default ACF
acf(resid(m2), 
  main='default ACF m2',
  lag.max=20, ylim=c(-.2,1)) # for comparison
# 5. acf_resid
acf_resid(m2, 
  main='acf_resid m2', ylab='ACF',
  max_lag=20, ylim=c(-.2,1)) # for comparison
# 6. acf_resid
acf_resid(m2, split_pred=c("Subject", "Trial"),
  main='acf_resid m2,\naverage',
  max_lag=20, ylim=c(-.2,1)) # for comparison
```


# <a id="partB"></a>PART B. Advanced plots

This section illustrates utility functions for extracting predictions from the model, in order to create your own plots. Most of the functions discussed in this section are essentially wrappers around `mgcv`'s `predict.gam` function. The function `predict.gam` requires as input the `gam` or `bam` object, that is the fitted model, and a data frame to generate predictions for. The functions discussed below facilitate in setting up the data frame to extract predictions for. In addition, `predict.gam` requires the type of predictions to be specified. In the `itsadug` functions this is set to `"terms"` for partial effects and `"lpmatrix"` for summed effects. (When you would like to use `type="link"` or `type="response"` it may be better to use `predict.gam` directly.)


## <a id="B1"></a>*1. Plotting random effects*

The standard way of plotting random effects is by using [plot.gam](#A1.plot.gam). For plotting a selection of random effects, or manipulating the layout of the plot, it is possible to extract the partial random effects as data frame.

## <a id="B1.get.random"></a>get_random

The function `get_random` returns values for all random effects in a data.frame. This is particularly useful for combining random effects in a single plot. However, by specifying a constant value for random effects terms in the `cond` argument it is also possible to generate the values of a single random effects and keep the others constant. 

```{r getrandom1}
output <- get_random(m1)
head(output)
```

The random effects could be plotted using a packag specialized in plotting, such as `lattice` or `ggplots`. (See `help(get_random)` for an example.) Alternatively, it is possble to make a custom plot as illustrated here:

```{r plotgetrandom1, fig.width=8, fig.height=4}
par(mfrow=c(1,2))

# default plot
emptyPlot(range(output[,2]), range(output[,1]), h0=0,
    main='s(Time, Subject)')
for(i in sort(unique(output$Subject))){
  tmp <- output[output$Subject==i,]
  lines(tmp$Time, tmp[,1],
        col=alpha(1)) 
}

# clearly clustering - maybe condition effect?
cluster <- simdat[,c("Subject", "Condition")]
cluster <- cluster[!duplicated( cluster ), ]

# plot with colors:
emptyPlot(range(output[,2]), range(output[,1]), h0=0)
for(i in sort(unique(output$Subject))){
  tmp <- output[output$Subject==i,]
  lines(tmp$Time, tmp[,1],
        col=rainbow(6)[cluster[cluster$Subject==i,'Condition']+2]) 
}
legend('topright',
    legend=-1:4,
    col=rainbow(6), lwd=1,
    bty='n')
```


The argument `fun` is optional: when specified the function is applied to each random effect separately.

```{r getrandom2, fig.width=4, fig.height=4}
# calculating the median of the random smooths for subjects:
fun1 <- get_random(m1, fun='median')
head(fun1[[1]])

# calculate the 25-75% interval:
interval <- function(x){
  quantile(x, prob=c(.25, .75))
}
fun2 <- get_random(m1, fun=interval)
head(fun2[[1]])


# calculating the mean of the random smooths for subjects,
# which is not necessarily 0:
fun3 <- get_random(m1, fun='mean')
head(fun3[[1]])

emptyPlot(range(fun1[[1]]$Time), c(-7, 7), h0=0,
    main="Summarizing random effects", xlab='Time (ms)', ylab='Est. of Y')
addInterval(pos=fun2[[1]]$Time, lowVals=fun2[[1]]$x[,1], highVals=fun2[[1]]$x[,2], 
    horiz=FALSE, length=0, col=alpha(1, f=.25), lwd=3, xpd=TRUE)
lines(fun1[[1]]$Time, fun1[[1]]$x, lwd=2)
lines(fun3[[1]]$Time, fun3[[1]]$x, lwd=2, lty=5, col='red')

legend('topright',
    legend=c('median', 'mean', '25-75%'),
    lwd=2, col=c(1,'red', alpha(1, f=.25)), 
    xpd=TRUE, bty='n')
```


Alternative(s): [plot.gam](#A1.plot.gam), [get_modelterm](#B1.get_modelterm)

[[Table of contents]](#toc)

## <a id="B1.get.modelterm"></a>get_modelterm

The function `get_modelterm` retrieves the predicted values for one particular modelterm, which allows for creating custom plots. These are basically the the values that specify the default [plot.gam](#a1.plot.gam) plots. Using this function, one partcular random effect (specified with the argument `select`) could be extracted as a list or as a data.frame. For random effects it's more convenient to output a data.frame, whcih could be requested by setting `as.data.frame` to `TRUE`.

```{r getmodelterm1}
# Select 4th modelterm in summary, which is the random effect:
output <- get_modelterm(m1, select=4, as.data.frame=TRUE)
# Note that the partial effects CI's are also provided:
head(output)
```

See the vignette `random` for interactive plots combining `get_modelterm` and `plot_smooth`:
```{r, eval=FALSE}
vignette('random')
```

The help file shows examples on how to plot these random effects with the packages `lattice` and `ggplot2`. Here we use custom plot functions from `itsadug`:

```{r getmodelterm.plot, fig.width=6, fig.height=4, results='hold'}
# changing the margins to add legend later:
defmar <- par()$mar
par(mar=defmar+c(0,0,0,3))

# setup empty plot:
emptyPlot(2000, c(-12,24), h0=0,
    main='Random effects with CI',
    xlab='Time (ms)')

# colors according to condition (between Subject manipulation):
cluster <- simdat[,c("Subject", "Condition")]
cluster <- cluster[!duplicated( cluster ), ]

# plot with colors:
for(i in sort(unique(output$Subject))){
  tmp <- output[output$Subject==i,]
  plot_error(tmp$Time, tmp$fit, tmp$se.fit, shade=TRUE,
        col=rainbow(6)[cluster[cluster$Subject==i,'Condition']+2]) 
}

legend(getFigCoords()[2], getFigCoords('hf')[2],
    xjust=1, yjust=.5,
    legend=sort(unique(output$Subject)),
    col=rainbow(6)[
      sapply(as.character(sort(unique(output$Subject))), 
          function(x){return(cluster[cluster$Subject==x,'Condition'])})+2],
    lwd=2, seg.len=1, ncol=2, cex=.65, bty='n', xpd=TRUE)

par(mar=defmar)

```

Alternatively, one could select a selection of Subjects. For example, the participants in Condition 2 and 3:

```{r getmodelterm2}
# Select 4th modelterm in summary, which is the random effect,
# and only select the subjects in Condition 2 and 3:
output <- get_modelterm(m1, select=4, as.data.frame=TRUE,
    cond=list(Subject=unique(simdat[simdat$Condition %in% c(2,3),]$Subject)))
```


```{r getmodelterm.plot2, fig.width=6, fig.height=4, results='hold'}
# changing the margins to add legend later:
defmar <- par()$mar
par(mar=defmar+c(0,0,0,3))

# setup empty plot:
emptyPlot(2000, c(-12,24), h0=0,
    main='Random effects with CI',
    xlab='Time (ms)')

# colors according to condition (between Subject manipulation):
cluster <- simdat[,c("Subject", "Condition")]
cluster <- cluster[!duplicated( cluster ), ]

# plot with colors:
for(i in sort(unique(output$Subject))){
  tmp <- output[output$Subject==i,]
  plot_error(tmp$Time, tmp$fit, tmp$se.fit, shade=TRUE,
        col=ifelse(substr(i,1,1)=="a",1, 2),
        lty=ifelse(cluster[cluster$Subject==i,'Condition']==2,1,2)) 
}

legend(getFigCoords()[2], getFigCoords('p')[4],
    xjust=1, yjust=1,
    legend=c('Cond 2, adults', 'Cond 2, children', 
             'Cond 3, adults', 'Cond 3, children'),
    col=rep(c(1,2), 2), lty=rep(c(1,2), each=2),
    lwd=2, seg.len=1, ncol=2, cex=.65, bty='n', xpd=TRUE)

par(mar=defmar)

```



# References

-----


